//////////////////////////////////////////////////////////////////////////
// Matt.Dobbs@Cern.CH, December 1999
// November 2000, updated to use Pythia 6.1
// example of generating events with Pythia
// using HepMC/PythiaWrapper.h 
// Events are read into the HepMC event record from the FORTRAN HEPEVT 
// common block using the IO_HEPEVT strategy and then output to file in
// ascii format using the IO_Ascii strategy.
//////////////////////////////////////////////////////////////////////////
// To Compile: go to the HepMC directory and type:
// gmake examples/example_MyPythia.exe
//
// In this example the precision and number of entries for the HEPEVT 
// fortran common block are explicitly defined to correspond to those 
// used in the Pythia version of the HEPEVT common block. 
//
// If you get funny output from HEPEVT in your own code, probably you have
// set these values incorrectly!
//

#include <iostream>
#include "HepMC/PythiaWrapper.h"
#include "HepMC/IO_HEPEVT.h"
#include "HepMC/IO_Ascii.h"
#include "HepMC/GenEvent.h"

#include "ANHEPMC/JetableInputFromHepMC.h"
#include "ANHEPMC/JetFinderUA.h"
#include "ANHEPMC/LeptonAnalyserHepMC.h"
    
int main() { 
    //
    //........................................HEPEVT
    // Pythia 6.1 uses HEPEVT with 4000 entries and 8-byte floating point
    //  numbers. We need to explicitly pass this information to the 
    //  HEPEVT_Wrapper.
    //
    HepMC::HEPEVT_Wrapper::set_max_number_entries(4000);
    HepMC::HEPEVT_Wrapper::set_sizeof_real(8);
    //
    //........................................PYTHIA INITIALIZATIONS
    // (Some platforms may require the initialization of pythia PYDATA block 
    //  data as external - if you get pythia initialization errors try 
    //  commenting in/out the below call to initpydata() )
    // initpydata();
    //
    // Select Z+g process (msel 13; actually 2 processes)
    // (here we have to be careful of C/F77 differences: arrays in C 
    //  start at 0, F77 at 1, so we need to subtract 1 from the process #)

    pysubs.msel=13; // Z+g
    pysubs.ckin[3-1]=20.; // qt low cut

    for ( int idc = pydat3.mdcy[2-1][23-1] ;
          idc < pydat3.mdcy[2-1][23-1] + pydat3.mdcy[3-1][23-1]; idc++ ) {
      if ( abs(pydat3.kfdp[1-1][idc-1]) != 11 &&
           abs(pydat3.kfdp[1-1][idc-1]) != 13 && // only lepton decay modes
           abs(pydat3.kfdp[1-1][idc-1]) != 15 )
        pydat3.mdme[1-1][idc-1] = min(0, pydat3.mdme[1-1][idc-1]);
    }

    // set random number seed (mandatory!)
    pydatr.mrpy[0]=55122 ;
    // Tell Pythia not to write multiple copies of particles in event record.
    pypars.mstp[128-1] = 2;
    // Example of setting a Pythia parameter: set the top mass 
    pydat2.pmas[1-1][6-1]= 175;  
    //
    // Call pythia initialization
    call_pyinit( "CMS", "p", "p", 14000. );

    //........................................HepMC INITIALIZATIONS
    //
    // Instantiate an IO strategy for reading from HEPEVT.
    HepMC::IO_HEPEVT hepevtio;
    //
    // Instantial an IO strategy to write the data to file - it uses the 
    //  same ParticleDataTable
    HepMC::IO_Ascii ascii_io("example_MyPythia.dat",std::ios::out);
    //
    JetableInputFromHepMC JI;
    JetFinderUA JF;
    LeptonAnalyserHepMC LA;
    //
    int ngood=0;
    //........................................EVENT LOOP
    for ( int i = 1; i <= 1000; i++ ) {
      if ( i%50==1 ) std::cout << "Processing Event Number " 
                               << i << std::endl;
      call_pyevnt();      // generate one event with Pythia
      // pythia pyhepc routine converts common PYJETS in common HEPEVT
      call_pyhepc( 1 );
      HepMC::GenEvent* evt = hepevtio.read_next_event();
      // add some information to the event:
      evt->set_event_number(i);
      //evt->set_signal_process_id(13); // should we retrieve the actual proc n?
      // write the event out to the ascii file:
      // ascii_io << evt;
      //
      vector<JetableObject> objects = JI.readFromHepMC(evt);
      vector<Jet> alljets = JF.findJets(objects);
      cout << "size of all jets = " << alljets.size() << endl;
      int nisolep = LA.nIsolatedLeptons(evt);
      cout << "size of isolated leptons = " << nisolep << endl;
      vector<Jet> jets = LA.removeLeptonsFromJets(alljets, evt);
      cout << "size of jets = " << jets.size() << endl;
      if(jets.size() >= 2 && nisolep >= 2) ngood++;
      //
      // we also need to delete the created event from memory
      delete evt;
    }
    //........................................TERMINATION
    // write out some information from Pythia to the screen
    cout << "Number of GOOD events: " << ngood << endl;
    call_pystat( 1 );    

    return 0;
}
